<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Safe Multipart Image Streaming + Download</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    img { max-width: 500px; border: 1px solid #ccc; margin-top: 1rem; }
    pre { background: #f4f4f4; padding: 1rem; border: 1px solid #ccc; }
    button { margin-top: 1rem; padding: 0.5rem 1rem; }
  </style>
</head>
<body>
  <h2>JSON Data</h2>
  <pre id="json-output">Waiting...</pre>

  <h2>Image Stream</h2>
  <img id="image-output" alt="Streaming image..." />
  <br />
  <button id="download-btn" style="display:none;">Download Image</button>

  <h2>Console Logs</h2>
  <pre id="log-output"></pre>

  <script>
    const log = (...args) => {
      console.log(...args);
      document.getElementById("log-output").textContent += args.join(" ") + "\n";
    };

    let finalBlob = null;

    async function fetchAndParseMultipart() {
      const response = await fetch("http://localhost:8080/multipart-data");
      const contentType = response.headers.get("content-type");

      if (!contentType.includes("multipart/form-data")) {
        log("Unexpected content type:", contentType);
        return;
      }

      const boundary = '--' + contentType.split("boundary=")[1];
      const rawBuffer = await response.arrayBuffer();
      const data = new Uint8Array(rawBuffer);
      const text = new TextDecoder().decode(data);

      const parts = text.split(boundary).filter(p => p.trim() && p.trim() !== "--");

      let imageStart = 0;
      let imageEnd = data.length;
      let jsonParsed = false;

      for (const part of parts) {
        if (part.includes('name="json_data"')) {
          const jsonMatch = part.match(/\\r\\n\\r\\n([\\s\\S]*)\\r\\n--/);
          if (jsonMatch && jsonMatch[1]) {
            const json = JSON.parse(jsonMatch[1].trim());
            document.getElementById("json-output").textContent = JSON.stringify(json, null, 2);
            log("✅ JSON parsed:", JSON.stringify(json));
          }
        }

        if (part.includes('name="image_data"')) {
          // Locate exact byte range of this part in original binary
          const partIndexInText = text.indexOf(part);
          const headerEndInPart = part.indexOf("\r\n\r\n") + 4;

          const textBeforeImage = text.slice(0, partIndexInText + headerEndInPart);
          imageStart = new TextEncoder().encode(textBeforeImage).length;

          const endBoundaryIndex = text.indexOf(boundary, partIndexInText + headerEndInPart);
          const textUntilNextBoundary = text.slice(0, endBoundaryIndex);
          imageEnd = new TextEncoder().encode(textUntilNextBoundary).length;

          log(`📍 Image bytes: start=${imageStart}, end=${imageEnd}, size=${imageEnd - imageStart}`);
        }
      }

      const imageBytes = data.slice(imageStart, imageEnd);
      finalBlob = new Blob([imageBytes], { type: "image/jpeg" }); // or image/png
      const url = URL.createObjectURL(finalBlob);
      document.getElementById("image-output").src = url;
      document.getElementById("download-btn").style.display = "inline-block";
      log(`✅ Image reconstructed. Blob size: ${finalBlob.size} bytes`);
    }

    document.getElementById("download-btn").addEventListener("click", () => {
      if (!finalBlob) return;
      const a = document.createElement("a");
      a.href = URL.createObjectURL(finalBlob);
      a.download = "streamed-image.jpg";
      a.click();
    });

    fetchAndParseMultipart();
  </script>
</body>
</html>
