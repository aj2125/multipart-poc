<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Streaming Multipart Form Data Viewer</title>
  <style>
    body { font-family: sans-serif; line-height: 1.5; padding: 1rem; }
    img { max-width: 400px; border: 1px solid #ccc; margin-top: 1rem; }
    pre { background: #f7f7f7; padding: 1rem; border: 1px solid #ddd; }
  </style>
</head>
<body>
  <h2>JSON Data</h2>
  <pre id="json-output">Waiting for JSON...</pre>

  <h2>Image (Progressive Streaming)</h2>
  <img id="image-output" alt="Loading image..." />

  <script>
    async function fetchStreamingFormData() {
      const response = await fetch('http://localhost:8080/multipart-data');
      const contentType = response.headers.get('content-type');

      if (!contentType.includes('multipart/form-data')) {
        console.error("Unexpected content type", contentType);
        return;
      }

      const boundary = '--' + contentType.split('boundary=')[1];
      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      let buffer = '';
      let imageChunks = [];
      let imageBytesSoFar = 0;
      let state = 'json';

      function updateImage() {
        const blob = new Blob(imageChunks, { type: 'image/jpeg' });
        const url = URL.createObjectURL(blob);
        document.getElementById('image-output').src = url;
      }

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        if (state !== 'stream-image') {
          const chunkText = decoder.decode(value, { stream: true });
          buffer += chunkText;

          while (true) {
            if (state === 'json' && buffer.includes('name="json_data"')) {
              const jsonStart = buffer.indexOf('\r\n\r\n') + 4;
              const jsonEnd = buffer.indexOf(boundary, jsonStart);
              const jsonStr = buffer.substring(jsonStart, jsonEnd).trim();
              try {
                const json = JSON.parse(jsonStr);
                document.getElementById('json-output').textContent = JSON.stringify(json, null, 2);
              } catch (e) {
                console.error("Invalid JSON:", jsonStr);
              }
              buffer = buffer.slice(jsonEnd);
              state = 'image-header';
              continue;
            }

            if (state === 'image-header' && buffer.includes('name="image_data"')) {
              const headerEnd = buffer.indexOf('\r\n\r\n') + 4;
              const leftover = buffer.slice(headerEnd);
              const leftoverBytes = new TextEncoder().encode(leftover);
              imageChunks.push(leftoverBytes);
              imageBytesSoFar += leftoverBytes.length;
              buffer = '';
              state = 'stream-image';
              break;
            }

            break;
          }
        } else {
          // Binary streaming mode
          imageChunks.push(value);
          imageBytesSoFar += value.length;

          if (imageBytesSoFar >= 100 * 1024) {
            updateImage();
            imageBytesSoFar = 0;
          }
        }
      }

      if (imageChunks.length > 0) updateImage();
    }

    fetchStreamingFormData();
  </script>
</body>
</html>
