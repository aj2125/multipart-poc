<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Progressive JPEG Streaming with Logs + Download</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    img { max-width: 500px; border: 1px solid #ccc; margin-top: 1rem; }
    pre { background: #f4f4f4; padding: 1rem; border: 1px solid #ccc; }
    button { margin-top: 1rem; padding: 0.5rem 1rem; }
  </style>
</head>
<body>
  <h2>JSON Data</h2>
  <pre id="json-output">Waiting...</pre>

  <h2>Progressive JPEG Image</h2>
  <img id="image-output" alt="Streaming image..." />

  <button id="download-btn" style="display:none;">Download Assembled Image</button>

  <h2>Console Logs</h2>
  <pre id="log-output"></pre>

  <script>
    let finalBlob = null;

    async function fetchStreamingMultipartJPEG() {
      const response = await fetch("http://localhost:8080/multipart-data");
      const contentType = response.headers.get("content-type");

      if (!contentType.includes("multipart/form-data")) {
        console.error("Unexpected content type", contentType);
        return;
      }

      const log = (...args) => {
        console.log(...args);
        document.getElementById("log-output").textContent += args.join(" ") + "\n";
      };

      const boundary = "--" + contentType.split("boundary=")[1];
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      let state = "json";
      let imageChunks = [];
      let imageBytesSoFar = 0;
      let chunkCount = 0;
      let totalBytes = 0;
      let serverReportedSize = null;

      function updateImage() {
        finalBlob = new Blob(imageChunks, { type: "image/jpeg" });
        const url = URL.createObjectURL(finalBlob);
        document.getElementById("image-output").src = url;
        log(`🔄 updateImage() called — blob size: ${finalBlob.size} bytes`);
      }

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunkCount++;
        totalBytes += value.length;
        log(`📦 Chunk ${chunkCount} received — ${value.length} bytes`);

        if (state !== "stream-image") {
          const chunkText = decoder.decode(value, { stream: true });
          buffer += chunkText;

          const jsonMatch = buffer.match(/name="json_data"[\s\S]+?Content-Type:\s*application\/json\r\n\r\n([\s\S]+?)\r\n--/);
          if (state === "json" && jsonMatch && jsonMatch[1]) {
            try {
              const jsonStr = jsonMatch[1].trim();
              const json = JSON.parse(jsonStr);
              document.getElementById("json-output").textContent = JSON.stringify(json, null, 2);
              log("✅ JSON parsed:", jsonStr);
              if (json.imageSize) {
                serverReportedSize = json.imageSize;
                log(`📏 Server-reported image size: ${serverReportedSize} bytes`);
              }
              buffer = buffer.slice(buffer.indexOf('name="image_data"'));
              state = "image-header";
            } catch (e) {
              log("❌ JSON parse error:", e);
            }
          }

          if (state === "image-header" && buffer.includes('name="image_data"')) {
            const headerEnd = buffer.indexOf("\r\n\r\n") + 4;
            const headerText = buffer.slice(0, headerEnd);
            const headerByteLength = new TextEncoder().encode(headerText).length;
            const leftoverBytes = value.slice(headerByteLength); // ✅ actual binary
            imageChunks.push(leftoverBytes);
            imageBytesSoFar += leftoverBytes.length;
            log(`🧩 First image bytes after header: ${leftoverBytes.length}`);
            buffer = "";
            state = "stream-image";
            updateImage();
          }
        } else {
          imageChunks.push(value);
          imageBytesSoFar += value.length;
          if (imageBytesSoFar >= 100 * 1024) {
            updateImage();
            imageBytesSoFar = 0;
          }
        }
      }

      if (imageChunks.length > 0) {
        updateImage();
        const totalReceived = imageChunks.reduce((a, b) => a + b.length, 0);
        log(`✅ Streaming complete — total image bytes: ${totalReceived}`);
        if (serverReportedSize !== null) {
          log(`🔍 Size match: ${serverReportedSize === totalReceived ? "✔️ yes" : `❌ no (expected ${serverReportedSize})`}`);
        }

        // ✅ Show download button
        document.getElementById("download-btn").style.display = "inline-block";
      }
    }

    // ✅ Download logic
    document.getElementById("download-btn").addEventListener("click", () => {
      if (!finalBlob) return;
      const a = document.createElement("a");
      a.href = URL.createObjectURL(finalBlob);
      a.download = "streamed-image.jpg";
      a.click();
    });

    fetchStreamingMultipartJPEG();
  </script>
</body>
</html>
