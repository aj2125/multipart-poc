<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Progressive JPEG Streaming with JSON</title>
  <style>
    body { font-family: sans-serif; line-height: 1.5; padding: 1rem; }
    img { max-width: 500px; border: 1px solid #ccc; margin-top: 1rem; }
    pre { background: #f7f7f7; padding: 1rem; border: 1px solid #ddd; }
  </style>
</head>
<body>
  <h2>JSON Data</h2>
  <pre id="json-output">Waiting...</pre>

  <h2>Progressive JPEG Image</h2>
  <img id="image-output" alt="Streaming image..." />

  <script>
    async function fetchStreamingMultipartJPEG() {
      const response = await fetch("http://localhost:8080/multipart-data");
      const contentType = response.headers.get("content-type");

      if (!contentType.includes("multipart/form-data")) {
        console.error("Unexpected content type", contentType);
        return;
      }

      const boundary = "--" + contentType.split("boundary=")[1];
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      let state = "json";
      let imageChunks = [];
      let imageBytesSoFar = 0;

      function updateImage() {
        const blob = new Blob(imageChunks, { type: "image/jpeg" });
        const url = URL.createObjectURL(blob);
        document.getElementById("image-output").src = url;
      }

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        if (state !== "stream-image") {
          const chunkText = decoder.decode(value, { stream: true });
          buffer += chunkText;

          // âœ… Safe JSON parsing with regex
          if (state === "json" && buffer.includes('name="json_data"')) {
            const jsonMatch = buffer.match(/name="json_data"[\s\S]+?Content-Type:\s*application\/json\r\n\r\n([\s\S]+?)\r\n--/);
            if (jsonMatch && jsonMatch[1]) {
              try {
                const jsonStr = jsonMatch[1].trim();
                const json = JSON.parse(jsonStr);
                document.getElementById("json-output").textContent = JSON.stringify(json, null, 2);
                buffer = buffer.slice(buffer.indexOf('name="image_data"')); // move ahead
                state = "image-header";
              } catch (e) {
                console.error("Invalid JSON:", e);
              }
            }
          }

          // Detect image part
          if (state === "image-header" && buffer.includes('name="image_data"')) {
            const headerEnd = buffer.indexOf("\r\n\r\n") + 4;
            const leftover = buffer.slice(headerEnd);
            const leftoverBytes = new TextEncoder().encode(leftover);
            imageChunks.push(leftoverBytes);
            imageBytesSoFar += leftoverBytes.length;
            buffer = "";
            state = "stream-image";
            updateImage();
          }
        } else {
          // Binary streaming mode
          imageChunks.push(value);
          imageBytesSoFar += value.length;

          if (imageBytesSoFar >= 100 * 1024) {
            updateImage();
            imageBytesSoFar = 0;
          }
        }
      }

      if (imageChunks.length > 0) updateImage();
    }

    fetchStreamingMultipartJPEG();
  </script>
</body>
</html>
