<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Progressive JPEG Streaming with Logs</title>
  <style>
    body { font-family: sans-serif; padding: 1rem; }
    img { max-width: 500px; border: 1px solid #ccc; margin-top: 1rem; }
    pre { background: #f4f4f4; padding: 1rem; border: 1px solid #ccc; white-space: pre-wrap; }
  </style>
</head>
<body>
  <h2>JSON Data</h2>
  <pre id="json-output">Waiting...</pre>

  <h2>Image Stream (Progressive JPEG)</h2>
  <img id="image-output" alt="Streaming image..." />

  <h2>Console Logs</h2>
  <pre id="log-output"></pre>

  <script>
    async function fetchStreamingMultipartJPEG() {
      const response = await fetch("http://localhost:8080/multipart-data");
      const contentType = response.headers.get("content-type");

      if (!contentType.includes("multipart/form-data")) {
        console.error("Unexpected content type", contentType);
        return;
      }

      const log = (...args) => {
        console.log(...args);
        document.getElementById("log-output").textContent += args.join(" ") + "\n";
      };

      const boundary = "--" + contentType.split("boundary=")[1];
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      let state = "json";
      let imageChunks = [];
      let imageBytesSoFar = 0;
      let chunkCount = 0;
      let totalBytes = 0;
      let serverReportedSize = null;

      function updateImage() {
        const blob = new Blob(imageChunks, { type: "image/jpeg" });
        const url = URL.createObjectURL(blob);
        document.getElementById("image-output").src = url;
        log(`üîÑ updateImage() called ‚Äî blob size: ${blob.size} bytes`);
      }

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        chunkCount++;
        totalBytes += value.length;
        log(`üì¶ Chunk ${chunkCount} received ‚Äî ${value.length} bytes`);

        if (state !== "stream-image") {
          const chunkText = decoder.decode(value, { stream: true });
          buffer += chunkText;

          const jsonMatch = buffer.match(/name="json_data"[\s\S]+?Content-Type:\s*application\/json\r\n\r\n([\s\S]+?)\r\n--/);
          if (state === "json" && jsonMatch && jsonMatch[1]) {
            try {
              const jsonStr = jsonMatch[1].trim();
              const json = JSON.parse(jsonStr);
              document.getElementById("json-output").textContent = JSON.stringify(json, null, 2);
              log("‚úÖ JSON parsed:", jsonStr);
              if (json.imageSize) {
                serverReportedSize = json.imageSize;
                log(`üìè Server-reported image size: ${serverReportedSize} bytes`);
              }
              buffer = buffer.slice(buffer.indexOf('name="image_data"'));
              state = "image-header";
            } catch (e) {
              log("‚ùå JSON parse error:", e);
            }
          }

          if (state === "image-header" && buffer.includes('name="image_data"')) {
            const headerEnd = buffer.indexOf("\r\n\r\n") + 4;
            const headerText = buffer.slice(0, headerEnd);
            const headerByteLength = new TextEncoder().encode(headerText).length;
            const leftoverBytes = value.slice(headerByteLength); // binary-safe
            imageChunks.push(leftoverBytes);
            imageBytesSoFar += leftoverBytes.length;
            log(`üß© First image bytes after header: ${leftoverBytes.length}`);
            buffer = "";
            state = "stream-image";
            updateImage();
          }
        } else {
          // Streaming binary JPEG chunks
          imageChunks.push(value);
          imageBytesSoFar += value.length;

          if (imageBytesSoFar >= 100 * 1024) {
            updateImage();
            imageBytesSoFar = 0;
          }
        }
      }

      if (imageChunks.length > 0) {
        updateImage();
        const totalImageBytes = imageChunks.reduce((acc, chunk) => acc + chunk.length, 0);
        log(`‚úÖ Final image complete ‚Äî total bytes received: ${totalImageBytes}`);
        if (serverReportedSize !== null) {
          log(`üîç Size match: ${serverReportedSize === totalImageBytes ? "‚úîÔ∏è yes" : "‚ùå no"}`);
        }
      }
    }

    fetchStreamingMultipartJPEG();
  </script>
</body>
</html>
