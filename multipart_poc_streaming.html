<script>
  async function fetchMultipartDataProgressive() {
    const response = await fetch('http://100.118.112.252:8080/multipart-data');
    const contentType = response.headers.get('content-type');

    if (!contentType || !contentType.includes('multipart')) {
      console.error('Unexpected content type:', contentType);
      return;
    }

    const boundary = '--' + contentType.split('boundary=')[1];
    const decoder = new TextDecoder();
    const reader = response.body.getReader();

    let state = 'looking-for-json';
    let textBuffer = '';
    let imageChunks = [];
    let imageBytesSoFar = 0;

    function updateImage() {
      const blob = new Blob(imageChunks, { type: 'image/jpeg' });  // or 'image/png' if using PNG
      const url = URL.createObjectURL(blob);
      document.getElementById('image-output').src = url;
    }

    while (true) {
      const { done, value } = await reader.read();
      if (done) break;

      if (state === 'looking-for-json') {
        const chunkText = decoder.decode(value, { stream: true });
        textBuffer += chunkText;

        if (textBuffer.includes('application/json')) {
          const jsonStart = textBuffer.indexOf('\r\n\r\n') + 4;
          const jsonEnd = textBuffer.indexOf(boundary, jsonStart);
          const jsonStr = textBuffer.substring(jsonStart, jsonEnd).trim();
          try {
            const jsonData = JSON.parse(jsonStr);
            document.getElementById('json-output').textContent = JSON.stringify(jsonData, null, 2);
            state = 'looking-for-image-header';
            textBuffer = '';
          } catch (e) {
            // JSON not ready yet
          }
        }
      }

      else if (state === 'looking-for-image-header') {
        const chunkText = decoder.decode(value, { stream: true });
        textBuffer += chunkText;

        if (textBuffer.includes('Content-Type: image/jpeg') || textBuffer.includes('Content-Type: image/png')) {
          state = 'streaming-image';
          const start = textBuffer.indexOf('\r\n\r\n') + 4;
          const leftover = textBuffer.slice(start);
          const leftoverBytes = new TextEncoder().encode(leftover); // okay here just once
          imageChunks.push(leftoverBytes);
          imageBytesSoFar += leftoverBytes.length;
          textBuffer = '';
        }
      }

      else if (state === 'streaming-image') {
        imageChunks.push(value);
        imageBytesSoFar += value.length;

        if (imageBytesSoFar >= 100 * 1024) {
          updateImage();
          imageBytesSoFar = 0;
        }
      }
    }

    if (imageChunks.length) updateImage();
  }

  fetchMultipartDataProgressive();
</script>
